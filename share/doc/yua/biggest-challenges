Source: https://forum.speeddemosarchive.com/post/yua3.html

i began this project after much consideration on 8 january of this year. in late 2008 and early 2009 i tried to rewrite anri in perl so that it would run under operating systems other than windows. i also needed to avoid windows-specific video processing tools, so anri.pl was calling mencoder, avidemux, afconvert (under os x), and so on. thanks to the help of several dedicated volunteers, i was able to get anri 4 nearly ready to release. there are actually a few runs on the site right now that were encoded using anri 4. but i had an "all or nothing" mentality - i was frustrated when i couldn't find a way to concatenate lossy input without the audio getting out of sync. i switched back and forth between mencoder and avidemux, rewriting a ton of code every time, and eventually i was exhausted, and i put the whole thing on hold.

today, among other things, i'm a qt c++ programmer for my day job. qt c++ is really interesting because it lets you write platform-independent code sort of like java, but it doesn't rely on a virtual machine like java, so you don't have nearly as many performance or memory problems. you can even compile qt c++ using microsoft's c++ compiler under windows if you want, and it's just as fast as native code, because it is, in fact, native code. anyway, qt c++ seemed like a good language for an anri replacement - and not just because i already knew it. i knew that i could use it to nail the cross-platform requirement. my primary concern going in was ffmpeg, which i would be forced to use to decode the input video and audio. for a while i toyed with writing my own decoder, but i realized that i would never be able to replace anri and the windows-based free video ecosystem it's built on without tapping the power of ffmpeg.

unfortunately, that power comes with a high price. i know people who work on ffmpeg may read this, so i want to be reasonable. i don't want to say ffmpeg is a piece of crap, because it's not - people have worked hard on it. the problem with ffmpeg is that it is written as though it's 1985. software has come a long way since then. it isn't about politics or "not invented here" - there are simply better ways of doing things now when you're writing code in a higher-level language. c++, all other things equal, is better than c for large projects, and *especially* for large projects intended for reuse as a library. that's what experience has taught me.

let me stop here and say that i'm not one of those guys who thinks the linux kernel should be rewritten in c++. that would be totally inappropriate. there is absolutely nothing wrong with using c to implement unix - in fact, that is its original purpose. i myself write c when it's appropriate. but ffmpeg is not the linux kernel. it's not even an operating system. it's just userspace code for decoding video streams, converting video data between various colorspaces, and so on. it's a library that should let you say "decode a video frame and convert it to this other format," but instead it takes over your own program with its unique memory management and data structure requirements. you may eventually do what you want with it, but you have reinvented the wheel ten times in the process.

when you use a library in c++, you should never have to know how it's managing memory or how it's storing data. well, it turns out there is no such thing as a c++ program that uses ffmpeg as a library. there is always going to be ffmpeg code in your program. even if you write an abstraction layer - as has been attempted in the past (http://code.google.com/p/ffmpeg-wrapper/) - the ffmpeg developers will just change the api so that it no longer works. it's not their intent to break your code - it's just that ffmpeg belongs to the ffmpeg authors and not to you. ffmpeg is not meant to be useful to you. it's just a hobbyist project.

and yet i had to use it. there was no better way. and here we are. i can't synchronize the video and the audio, because when i decode an aac stream, ffmpeg silences the right channel. the standalone ffmpeg binary, some 3,219 lines long, somehow manages to avoid silencing the right channel when it decodes an aac stream. that means there is an "error" in my ffmpeg code somewhere. asking for help yields nothing (http://libav-users.943685.n4.nabble.com/Libav-user-stereo-AAC-decoding-right-channel-is-silence-td4656465.html). so i just bundle the standalone ffmpeg binary and use it to convert the audio separately, resulting in desync in the final output unless the planets are perfectly aligned and your input is flawless. it's also impossible to concatenate input streams this way without desync, which leaves yua with around the same level of functionality as anri 4 from 2009. thanks to ffmpeg, i can't do what typing "++" does in the avisynth language.

aside from the synchronization problem, i believe i actually have ffmpeg mostly under control in yua at present - knock on wood. the other major challenge i face now is the d1 deinterlacing situation. anri 3.3 uses an avisynth plug-in by scharfis_brain called mvbob. several years ago, its output quality was unparalleled. now, there are better alternatives (http://forum.speeddemosarchive.com/post/audio_desync_with_dazzle__amarec_27.html). nnedi3, an avisynth plug-in i ported to work under yua, equals the quality of mvbob for f2 streams because its characteristic fluttering on text is canceled out by the decimation to f2. f1 results are usually passable unless watched in slow motion, when fluttering becomes apparent.

i chose nnedi3 over mvbob because the latter is written in the avisynth language. sometimes, avisynth plug-ins are actually c or c++ programs, and these are much easier (relatively speaking) for me to repurpose for yua. this was the case with nnedi3. also, all other things equal, nnedi3 is much faster than mvbob - it can run in realtime on a four year old machine. unfortunately, the assembly-optimized parts of nnedi3 are written assuming 32-bit intel calling convention, and i haven't found the time to port all that code to amd64 as yet, so nnedi3 in yua is currently just as slow as mvbob.

overall, this situation is very difficult. qtgmc is the current state of the art in the avisynth ecosystem. ballofsnow has already stated that anri 3.4 will use it instead of mvbob. but qtgmc is written in avisynth, and it calls many avisynth plugins to do its work (one of them is nnedi3!). making it work in yua would involve porting the entire mvtools suite as well as rewriting the qtgmc core. at this point it almost makes more sense to write an avisynth abstraction layer - to attempt to parse the avisynth language, and so on. but that reeks of scope creep. avisynth is irrelevant to yua's purpose. i just want it to look good when i deinterlace d1 material at double the framerate.

i would appreciate any constructive input folks might have in these areas. thanks.

-- Nathan 'nate' Jahnke, 2013-02-09

